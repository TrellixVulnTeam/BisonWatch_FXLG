{"version":3,"file":"fullJoin.js","sources":["../../src/fullJoin.ts"],"sourcesContent":["import { Datum, TidyFn } from './types';\nimport { isMatch, makeByMap, autodetectByMap, JoinOptions } from './innerJoin';\nimport { O } from 'ts-toolbelt';\n\n/**\n * Performs a full join on two collections\n * @param itemsToJoin The rows/items to be appended to end of collection\n */\nexport function fullJoin<T extends Datum, JoinT extends Datum>(\n  itemsToJoin: JoinT[],\n  options?: JoinOptions<JoinT, T> | null | undefined\n): TidyFn<T, O.Merge<T, Partial<JoinT>>> {\n  const _fullJoin: TidyFn<T, O.Merge<T, Partial<JoinT>>> = (\n    items: T[]\n  ): O.Merge<T, Partial<JoinT>>[] => {\n    // convert by option in to a map from T key to JoinT key\n    const byMap =\n      options?.by == null\n        ? autodetectByMap(items, itemsToJoin)\n        : makeByMap(options.by);\n\n    // keep track of what has been matched\n    const matchMap = new Map();\n\n    const joined = items.flatMap((d: T) => {\n      const matches = itemsToJoin.filter((j: JoinT) => {\n        const matched = isMatch(d, j, byMap);\n        if (matched) {\n          matchMap.set(j, true);\n        }\n        return matched;\n      });\n      return matches.length ? matches.map((j: JoinT) => ({ ...d, ...j })) : d;\n    });\n\n    // add in the ones we missed\n    for (const item of itemsToJoin) {\n      if (!matchMap.has(item)) {\n        joined.push(item);\n      }\n    }\n\n    return joined;\n  };\n  return _fullJoin;\n}\n"],"names":["autodetectByMap","makeByMap","isMatch"],"mappings":";;;;;;kBASE,aACA;AAEA,QAAM,YAAmD,CACvD;AAGA,UAAM,QACJ,oCAAS,OAAM,OACXA,0BAAgB,OAAO,eACvBC,oBAAU,QAAQ;AAGxB,UAAM,WAAW,IAAI;AAErB,UAAM,SAAS,MAAM,QAAQ,CAAC;AAC5B,YAAM,UAAU,YAAY,OAAO,CAAC;AAClC,cAAM,UAAUC,kBAAQ,GAAG,GAAG;AAC9B,YAAI;AACF,mBAAS,IAAI,GAAG;AAAA;AAElB,eAAO;AAAA;AAET,aAAO,QAAQ,SAAS,QAAQ,IAAI,CAAC,WAAmB,MAAM,OAAQ;AAAA;AAIxE,eAAW,QAAQ;AACjB,UAAI,CAAC,SAAS,IAAI;AAChB,eAAO,KAAK;AAAA;AAAA;AAIhB,WAAO;AAAA;AAET,SAAO;AAAA;;;;"}